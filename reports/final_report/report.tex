
\documentclass[a4paper, 10pt, titlepage]{report}

%% Mandatory stuff
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
%% --


%% Color package for colored links
\usepackage[usenames,dvipsnames]{xcolor}
\definecolor{blues}{RGB}{153,50,204}
%% --


%% Code listings
\usepackage{listings}
% UTF8 compatibility options
% UTF8 chars are OK in code comment
% but not elsewhere
\lstset{extendedchars=false, texcl}
% Eye candy


\lstdefinestyle{python}{
  language=python,
  basicstyle=\footnotesize\rmfamily,
  identifierstyle=,
  commentstyle=\itshape,
  keywordstyle=,
  stringstyle=,
  showspaces=false,
  showstringspaces=false,
  tabsize=3,
  breaklines=true
}

\newcommand{\code}[1]{\lstinline!#1!}

\lstset{style=python}

%% Theorems environments
\usepackage{amsmath}
\usepackage{amsthm}

%% Hyperlinks for references, in color-O-vision and nice for long urls
\PassOptionsToPackage{hyphens}{url}\usepackage[pdftex,%
  pdfauthor={Marie Delavergne},%
  pdftitle={Mémoire de Master 2 ALMA},%
  pdfsubject={Mémoire de Master 2 ALMA - Un intergiciel d’une base de données NewSQL qui considère la localité de l’application cliente},%
  colorlinks,%
  linkcolor=blues,%
  urlcolor=blues,%
  plainpages=false]{hyperref}
%% --

%% Power to the tikz!
\usepackage{tikz}
%\usepackage{graphicx}
%% --

%% Page layout
\usepackage{makeidx}
\makeindex

%% Plain page headings
\pagestyle{headings}

%% Smaller space between heading and matter
\setlength\headsep{0.5in}
 %% --

%% Larger page
\usepackage[left=4cm,right=4cm,top=5cm,bottom=4cm]{geometry}

%% Adjust toc depth
\setcounter{tocdepth}{4}

%% Dotted toc
\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}

%% Figures where I want them
\usepackage{float}

%% Nice caption
\usepackage[font={footnotesize}]{caption}

%% Footnote where they belong
\usepackage[bottom]{footmisc}

%% Comments
\newcommand{\comment}[1]{}

%% Image in title
\usepackage{graphicx}

%% Subfigures
\usepackage{subcaption}

%% Bibliography
\usepackage[style=numeric]{biblatex}

\addbibresource{biblio.bib}

\begin{document}
%
%% \maketitle
\begin{titlepage}
	\centering
	{\scshape\LARGE\bfseries Un intergiciel d’une base de données NewSQL qui considère la localité de l’application cliente \par}
	\vspace{0cm}
	{\Large\itshape Marie Delavergne\par}
        {\Large - Mémoire de Master 2 ALMA -\par}

	\vfill

        % Bottom of the page
        {\Large Inria - Discovery Initiative / LS2N - Stack team\par}
        {\Large Ronan-Alexandre Cherrueau - Achour Mostefaoui \par}
	{\Large University of Nantes - 2017-2018 \par}

\begin{figure}[!h]\centering
   \begin{minipage}{0.3\textwidth}
     \centerline{\includegraphics[width=\linewidth]{no_push/logo_un2012quadri_larg40.png}}
     \label{Fig:univnantes}
   \end{minipage}
   \begin {minipage}{0.3\textwidth}
     \centerline{\includegraphics[width=\linewidth]{no_push/inr_logo_eng_rouge.png}}
     \label{Fig:inria}
   \end{minipage}
\end{figure}



\end{titlepage}


\clearpage
\tableofcontents
\newpage

\addcontentsline{toc}{section}{Introduction}
\section*{Introduction}


\addcontentsline{toc}{section}{Étude de l'existant}
\section{Étude de l'existant}

Two databases were considered: one distributed, CockroachDB, and the other replicated, MariaDB Galera Cluster.

\subsection{MariaDB Galera Cluster}

MariaDB, an open-source fork of MySQL, uses Galera Cluster as a synchronous multi-master cluster. It means that all nodes in the cluster are masters, with an active-active synchronous replication, so it is possible to read or write on every node at any time.

\begin{figure}[H]
  \vspace{-10pt}
  \centering
  \centerline{\includegraphics[width=1\textwidth]{no_push/galera-2.pdf}}
  \vspace{-5pt}
  \caption{MariaDB Galera Cluster}
  \vspace{-5pt}
  \label{fig:MGC}
\end{figure}

To say it in a more understandable way, MariaDB Galera Cluster allows to have the exact same database on every nodes thanks to a synchronous replication.
\\

To dive more into details, each time a transaction is requested by a client on a node, it is processed as usual until the client issues a commit. The process is stopped and all changes made to the database in the transaction are collected in a ``write-set'', along with the primary keys of the changed rows. The write-set is then broadcasted to every nodes. It then undergoes a deterministic certification test which uses the given primary keys. It actually checks all transactions between the current transaction and the last successful one to determine whether the primary keys involved conflicts between each others.

If the check fails, the whole transaction is rollbacked, and if it succeeds it is applied on all nodes then committed.

\begin{figure}[H]
  \vspace{-10pt}
  \centering
  \centerline{\includegraphics[width=0.85\textwidth]{no_push/certification_based_replication.png}}
  \vspace{-5pt}
  \caption{Certification Based Replication from \url{http://galeracluster.com} }
  \vspace{-5pt}
  \label{fig:MGC}
\end{figure}

This is pretty efficient since it only needs a broadcast to make the replication, which means. But this means that when it fails, the entire transaction must be retried and so it may lead to more conflicts and even deadlocks.

It also have advantages like granting there will be no data loss when nodes crash, providing a high availability across the cluster.

Galera Cluster uses a virtual synchrony that unifies the data delivery, providing a formalism for its semantics. Since this does not guarantee temporal synchrony, it also implements a flow control to keep nodes synchronized.

The multi-master replication allows only read-repeatable isolation at best for transactions, but more will be said on the subject in section \ref{sec:serial}, \pageref{sec:serial}.


\subsection{CockroachDB}

CockroachDB is a NewSQL distributed database that uses the Raft protocol (an alternative version to Lamport's Paxos consensus protocol). It uses the SQL API to enable SQL requests on every nodes. These requests are translated to key-value operations and -if needed- distributed across the cluster.

CockroachDB implements a single, monolithic sorted map for the keys and values stored.



Each node in the cluster holds replicas of ranges, which are sets of contiguous and sorted data from the cluster.

\begin{figure}[H]
  \vspace{-10pt}
  \centering
  \centerline{\includegraphics[width=0.85\textwidth]{no_push/cockroachdb.png}}
  \vspace{-5pt}
  \caption{CockroachDB ranges, replicas and leaseholders} }
  \vspace{-5pt}
  \label{fig:MGC}
\end{figure}

Each ranges have three replicas and one of them act as the leaseholder, a sort of leader that coordinates all reads and writes for the range. A read only requires the leaseholder.
When a write is requested, the leaseholder prepares to append it to its log, forward the request to the replicas and when the quorum is achieved, commit the change by add it in the log. The quorum is an agreement from two out of the three replicas to make the change.

\begin{figure}[H]
  \vspace{-10pt}
  \centering
  \centerline{\includegraphics[width=0.85\textwidth]{no_push/commit-cockroach.png}}
  \vspace{-5pt}
  \caption{CockroachDB commit: only a quorum of 2 is required to commit }
  \vspace{-5pt}
  \label{fig:MGC}
\end{figure}

\label{sec:serial}
\section{Serializability}
Difference between Serializable and Snapshot Isolations from \href{https://www.cockroachlabs.com/blog/what-write-skew-looks-like/}{Cockroach Labs}:


Consider the following transactions:
\begin{table}[H]
  \centering
  \begin{tabular}{ c }
    $P:   y \gets x$\\
    $Q:   x \gets y$\\
  \end{tabular}
\end{table}

There are two possible serial executions: $P$ then $Q$ OR $Q$ then $P$
\begin{table}[H]
  \centering
  \begin{tabular}{ r | l }
    (P) $y \gets x$ & $x \gets y$ (Q) \\
    (Q) $x \gets y$ & $y \gets x$ (P) \\
    $x = y$ & $x = y$ \\
  \end{tabular}
\end{table}

Snapshot isolation allows another execution:

\begin{table}[H]
  \centering
  \begin{tabular}{ r | l }
    1. P reads $x$ as $x_1$ & 2. Q reads $y$ as $y_1$ \\
    3. P writes $x_1$ to $y$ & 3. Q writes $y_1$ to $x$ \\
  \end{tabular}
  \\
  $x \neq y$, values have been swapped
\end{table}

Indeed, each transaction kept a consistent view of the database and the writes were not on the same value, so no overlaping of the transaction write set occured, then no retries were triggered.


\end{document}
